<!-- Loading tensorflow.js and jquery -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.1/dist/tf.min.js"></script>
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script> 
<!-- Model register and loading of coder specs -->
<script>
    var model_path = "./tmp/"
    var coder_specs = {name: "coder_specs"};
    registered_model_names=["slovak", "english", "german"];
    // FIXME : coder specs loading somehow not working in this order....
    for (model_name of registered_model_names) {
        $.getJSON(model_path+model_name+"/coder.json", function(data){coder_specs[model_name]=data})
    }
</script>


<!-- Web interface -->
<label for="word_start">Name should start with:</label>
<input type="text" id="word_start" name="word_start" minlength="0" maxlength="20" size="12">
<br>
<label for="randomness">Randomness coefficient (0-no randomness, >1: very random)</label>
<input type="number" id="randomness" name="randomness" min="0" max="10" value=0.8 size=5, step=0.01>
<br>
<label for="model">Language model:</label>
<select name="model" id="model">
</select>
<script>
    for (model_name of registered_model_names)
    document.getElementById('model').add(new Option(model_name, model_name))
</script>
<br>
<input type="button" value="Generate!" id="generate" onclick=predict> 
<br>
<p id="output"></p>

<script>
const wordStartElem = document.getElementById("word_start");
const randomnessElem = document.getElementById("randomness");
const modelElem = document.getElementById("model")
const generateElem = document.getElementById("generate")
const outputElem = document.getElementById("output")
modelElem.addEventListener("change", loadModel)
generateElem.addEventListener("click", predict)
var models = {active: null};

// function for loading model
async function loadModel(){
    model_name = modelElem.value
    models.active = model_name
    if (!(model_name in models)){
        console.log("loading model "+model_name)
        generateElem.disabled = true
        var loaded_model = await tf.loadLayersModel(model_path+model_name+"/model.json")
        models[model_name] = loaded_model
        generateElem.disabled = false
    }
    else {
        generateElem.disabled = false
    }
}
// single character prediction function
async function predict(wordstart, randomness){
    var new_character;
    var token_wordstart = coder_specs[models.active].start_token + wordstart
    for (var k=0; k<coder_specs[models.active].max_word_size; k++){
        var input_tensor = tf.tensor(encode(token_wordstart));
        var output_tensor = await models[models.active].predict(input_tensor);
        var output_ar = await output_tensor.array()  ;
        new_character = decodeCharacter(output_ar[0][wordstart.length], randomness);
        if (new_character==coder_specs[models.active].end_token){
            break;
        }
        else{
            token_wordstart=token_wordstart+new_character
        }
    }
    output.value = token_wordstart.substring(1)
}
// word to one-hot encoding function
function encode(word){
    const max_word_size = coder_specs[models.active].max_word_size
    const one_hot_size = coder_specs[models.active].one_hot_size
    const chardict = coder_specs[models.active].chardict
    var word = word.toLowerCase() + coder_specs[models.active].end_token.repeat(max_word_size-word.length)
    var code= new Array(1).fill(new Array(max_word_size).fill(new Array(one_hot_size).fill(0.0)))
    for (var k=0; k<max_word_size; k++){
        code[0][k][chardict[word[k]]] = 1.0
    }
    return code
}
// probability to character decoding function
function decodeCharacter(probabilities, randomness){
    if (randomness>0.0){
        var rescaled = probabilities.map( (x)=> {return x**1/randomness})
        var norm_factor = rescaled.reduce((a, b) => a + b, 0)
        var new_probs = rescaled.map((x)=>x/norm_factor)
        var charnum = randomIntegerWithProbs(new_probs)
    }
    else{
        var charnum = argMax(probabilities) 
    }
    var charnum = randomIntegerWithProbs(new_probs)
    return coder_specs[models.active].charlist[charnum]
}
// helper function for probability sampling
function randomIntegerWithProbs(probabilities){
    var cummulative_prob=0.0
    var num = 0
    var sampled_prob = Math.random()
    for (prob of probabilities){
        cummulative_prob = cummulative_prob + prob
        if (sampled_prob <= cummulative_prob){
            return num
        }
        else {
            num++
        }
        return probabilities.length -1 // just to be safe in case of rounding problems
    }
}
// helper argmax function from https://gist.github.com/engelen/fbce4476c9e68c52ff7e5c2da5c24a28
function argMax(array) {
  return array.map((x, i) => [x, i]).reduce((r, a) => (a[0] > r[0] ? a : r))[1];
}

// load the model
x=loadModel(modelElem.value)
outputElem.innerHTML=models.active
</script>


<!-- Loading tensorflow.js and jquery -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.1/dist/tf.min.js"></script>
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script> 
<!-- Model register and loading of coder specs -->
<script>
    var model_path = "./tmp/"
    var coder_specs = {name: "coder_specs"};
    registered_model_names=["slovak", "english", "german"];
    // FIXME : coder specs loading somehow not working in this order....
    for (model_name of registered_model_names) {
        $.getJSON(model_path+model_name+"/coder.json", function(data){coder_specs[model_name]=data})
    }
</script>


<!-- Web interface -->
<label for="word_start">Name should start with:</label>
<input type="text" id="word_start" name="word_start" minlength="0" maxlength="20" size="12">
<br>
<label for="randomness">Randomness coefficient (0-no randomness, >1: very random)</label>
<input type="number" id="randomness" name="randomness" min="0" max="10" value=0.8 size=5, step=0.01>
<br>
<label for="model">Language model:</label>
<select name="model" id="model">
</select>
<script>
    for (model_name of registered_model_names)
    document.getElementById('model').add(new Option(model_name, model_name))
</script>
<br>
<input type="button" value="Generate!" id="generate" onclick=predict> 
<br>
<p id="output"></p>

<script>
const wordStartElem = document.getElementById("word_start");
const randomnessElem = document.getElementById("randomness");
const modelElem = document.getElementById("model")
const generateElem = document.getElementById("generate")
const outputElem = document.getElementById("output")
modelElem.addEventListener("change", loadModel)
generateElem.addEventListener("click", predict)
var models = {active: null};

// function for loading model
async function loadModel(){
    model_name = modelElem.value
    models.active = model_name
    if (!(model_name in models)){
        console.log("loading model "+model_name)
        generateElem.disabled = true
        var loaded_model = await tf.loadLayersModel(model_path+model_name+"/model.json")
        models[model_name] = loaded_model
        generateElem.disabled = false
    }
    else {
        generateElem.disabled = false
    }
}
// prediction function
async function predict(){
    // replace this loading by prediction!
    var wordstart = coder_specs[models.active].start_token + wordStartElem.value
    outputElem.innerHTML=loaded_model+modelElem.value+randomnessElem.value+wordStartElem.value
}
// word to one-hot encoding function
function encode(word){
    const max_word_size = coder_specs[models.active].max_word_size
    const one_hot_size = coder_specs[models.active].one_hot_size
    const chardict = coder_specs[models.active].chardict
    var word = word + coder_specs[models.active].end_token.repeat(max_word_size-word.length)
    var code= new Array(1).fill(new Array(max_word_size).fill(new Array(one_hot_size).fill(0.0)))
    for (var k=0; k<max_word_size; k++){
        code[0][k][chardict[word[k]]] = 1.0
    }
    return code
}
// probability to character decoding function
function decodeCharacter(probabilities, randomness){
    if (randomness>0.0){
        var rescaled = probabilities.map( (x)=> {return x**1/randomness})
        var norm_factor = rescaled.reduce((a, b) => a + b, 0)
        var new_probs = rescaled.map((x)=>x/norm_factor)
        var charnum = randomIntegerWithProbs(new_probs)
    }
    else{
        var charnum = argMax(probabilities) 
    }
    var charnum = randomIntegerWithProbs(new_probs)
    return coder_specs[models.active].charlist[charnum]
}
// helper function for probability sampling
function randomIntegerWithProbs(probabilities){
    var cummulative_prob=0.0
    var num = 0
    var sampled_prob = Math.random()
    for (prob of probabilities){
        cummulative_prob = cummulative_prob + prob
        if (sampled_prob <= cummulative_prob){
            return num
        }
        else {
            num++
        }
        return probabilities.length -1 // just to be safe in case of rounding problems
    }
}
// helper argmax function from https://gist.github.com/engelen/fbce4476c9e68c52ff7e5c2da5c24a28
function argMax(array) {
  return array.map((x, i) => [x, i]).reduce((r, a) => (a[0] > r[0] ? a : r))[1];
}

// load the model
x=loadModel(modelElem.value)
outputElem.innerHTML=models.active
</script>

